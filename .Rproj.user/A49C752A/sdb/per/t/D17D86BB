{
    "collab_server" : "",
    "contents" : "#' Convolutive regression function\n#'\n#' Convolutive regression function\n#' @param formula.resp response\n#' @param formula.mu1 formula for variable1 expectation\n#' @param formula.sigma1 formula for variable1 variance\n#' @param formula.mu2 formula for variable2 expectation\n#' @param formula.sigma2 formula for variable2 variance\n#' @param data dataset\n#' @param dist1 chain of character to idnetify the distribution of variable1\n#' @param dist2 chain of character to idnetify the distribution of variable2\n#' @param fixed set the parameters that are fixed to some specified values\n#' @param na.action action for NA values\n#' @param method estimation method\n#' @param debug getting into the function\n#' @param quiet display comments.\n#' @param weights weights.\n#' @param scale Should the observations be scales\n#' @param scaleInit Initial value of the scaling.\n#' @param ... additional parameters\n#' @keywords convreg\n#' @export\n#' @examples\n#' set.seed(123)\n#' e=0.75+rnorm(n=500,mean=0,sd=0.25)\n#' x1 = rnorm(500,0,0.5)\n#' x2 = runif(500,-2,1)\n#' k= rnbinom(500,mu=exp(x2),size=1.5)\n#' y= data.frame(obs=(k + e) , f1 = x1, f2 = x2)\n#' par(mfrow = c(1,1), mar = c(5,4,4,2))\n#' hist(y$obs, breaks = seq(min(y$obs)-1.5, max(y$obs)+3, 3), xlim = c(0,14*24))\n#' res.reg.em =convreg( ~obs,\n#'           formula.mu1 =~ f2,\n#'           formula.mu2 =~ f1,\n#'           data=y,\n#'           dist1 = \"Nbinom\",\n#'           method = \"mle\")\n#' res.reg.em\n#' summary(res.reg.em)\n#' distplot(res.reg.em, delta=3, xlim=c(0,200))\nconvreg = function(formula.resp,\n                   formula.mu1= ~ 1,\n                   formula.sigma1= ~ 1,\n                   formula.mu2 = ~ 1,\n                   formula.sigma2 = ~ 1,\n                   data,\n                   dist1=\"Nbinom\",                        # nass density\n                   dist2=\"Gauss\",\n                   fixed = NULL,\n                   na.action,\n                   method = \"mle\",\n                   debug=FALSE,\n                   quiet = TRUE,\n                   weights = NULL,\n                   scale = FALSE,\n                   scaleInit = 1,\n                   ...){\n\n\n   # case of mix of dist1 and dist2\n   # case: dist1 == dist2 , stop with error messag e\n   # case: dist1 != dist2 , but not in the dist.\n\n   # method = \"mle\"\n   #          \"pen\"\n   #require(maxLik, CompGLM, compoisson)\n\n   call <- match.call()\n\n   if (missing(data)) {\n      #data <- environment(formula.mu1)\n      data <- environment(formula.resp)\n   }\n\n   transforms = rep(NA,4)\n\n   # automatically asign to transformation type for specific distribution\n   if(dist1 %in% c(\"Nbinom\",\"CoMPoisson\",\"Pois\")){transforms[1:2] = c(\"pos\",\"pos\")}\n   if(dist1 %in% c(\"Binom\")){transforms[1:2] = c(\"01\",\"id\")}\n   if(dist1 %in% c(\"Multinom\")){transforms[1:2] = c(\"pos\",\"id\")}\n   if(dist1 %in% c(\"ZIP\")){transforms[1:2] = c(\"pos\",\"01\")}\n   if(dist1 %in% c(\"HP\")){transforms[1:2] = c(\"pos\",\"01\")}\n\n   if(dist2 %in% c(\"Gauss\",\"Lnorm\")){transforms[3:4] = c(\"id\",\"pos\")}\n   if(dist2 %in% c(\"Gamma\")){transforms[3:4] = c(\"pos\",\"pos\")}\n\n   data[which(is.na(data),arr.ind=T)] = 0\n\n   keep.vars = c(all.vars(formula.resp),all.vars(formula.mu1),all.vars(formula.sigma1),all.vars(formula.mu2),all.vars(formula.sigma2))\n\n   if(length(keep.vars)>1){data = data[,which(colnames(data) %in% keep.vars)]\n   }else{data=as.data.frame(data.matrix(model.frame(formula.resp, data = data, na.action=NULL)))}\n\n   if(is.null(weights)){weights = rep(1, nrow(data))}\n\n   if(debug){browser()}\n\n   y = data.matrix(model.frame(formula.resp, data = data, na.action=NULL))\n\n   if(dist1 == \"Binom\" & length(which(fixed$name == \"sigma 1: (Intercept)\")) == 0){\n      fixed$name = c(fixed$name, \"sigma 1: (Intercept)\")\n      fixed$value = c(fixed$value, max(1,ceiling(y)))\n   }\n\n   # parameter estimation of 4\n\n   X.mu1.model.frame = model.frame(formula.mu1,data = data,na.action=NULL, drop.unused.levels = TRUE)\n   X.mu1.model.terms = attr(X.mu1.model.frame,\"terms\")\n   X.mu1 = model.matrix(X.mu1.model.terms, X.mu1.model.frame)\n\n   X.sigma1.model.frame = model.frame(formula.sigma1,data = data,na.action=NULL, drop.unused.levels = TRUE)\n   X.sigma1.model.terms = attr(X.sigma1.model.frame,\"terms\")\n   X.sigma1 = model.matrix(X.sigma1.model.terms, X.sigma1.model.frame)\n\n   X.mu2.model.frame = model.frame(formula.mu2,data = data,na.action=NULL, drop.unused.levels = TRUE)\n   X.mu2.model.terms = attr(X.mu2.model.frame,\"terms\")\n   X.mu2 = model.matrix(X.mu2.model.terms, X.mu2.model.frame)\n\n   X.sigma2.model.frame = model.frame(formula.sigma2,data = data,na.action=NULL, drop.unused.levels = TRUE)\n   X.sigma2.model.terms = attr(X.sigma2.model.frame,\"terms\")\n   X.sigma2 = model.matrix(X.sigma2.model.terms, X.sigma2.model.frame)\n\n\n      # link to the parameter\n   theta.mu1 = rep(0.1,ncol(X.mu1))\n   theta.sigma1 = rep(0.1,ncol(X.sigma1))\n   theta.mu2 = rep(0.1,ncol(X.mu2))\n   theta.sigma2 = rep(0.1,ncol(X.sigma2))\n\n\n      # Setup constraints on parameters\n   fun1 = eval(parse(text=paste(\"f\",transforms[1],sep=\"\")))\n   fun2 = eval(parse(text=paste(\"f\",transforms[2],sep=\"\")))\n   fun3 = eval(parse(text=paste(\"f\",transforms[3],sep=\"\")))\n   fun4 = eval(parse(text=paste(\"f\",transforms[4],sep=\"\")))\n   if(!quiet){message(sprintf('links: [formula1: %s sigma1: %s, formula2 : %s sigma2 : %s]',\n                   transforms[1],transforms[2],transforms[3],transforms[4]))}\n\n   # setup initialization for the optimization algo\n   # in future, we gonna do more comb of distribbutio.\n\n\n   if(dist1 == \"Pois\"){fixed$name = c(fixed$name,\"sigma 1: (Intercept)\")\n   fixed$value = c(fixed$value,0)}\n\n   theta.name = c(paste(\"mu 1: \",colnames(X.mu1),sep=\"\"),\n                  paste(\"sigma 1: \",colnames(X.sigma1),sep=\"\"),\n                  paste(\"mu 2: \",colnames(X.mu2),sep=\"\"),\n                  paste(\"sigma 2: \",colnames(X.sigma2),sep=\"\"))\n\n   init.theta = initthetaConvreg(y,dist1,dist2,formula.mu1, formula.sigma1, formula.mu2, formula.sigma2,\n                                   fixed,data,theta.name, scale, scaleInit, debug)\n\n   idx.fixed = as.numeric(na.omit(match(fixed$name,theta.name)))\n   idx.var   = which(!(theta.name %in% fixed$name))\n\n   listParam = list(init.theta=init.theta,data = data,\n                    formula.resp = formula.resp, formula.mu1 = formula.mu1, formula.sigma1 = formula.sigma1, formula.mu2 = formula.mu2, formula.sigma2 = formula.sigma2,\n                    dist1 = dist1, dist2 = dist2,weights = weights, quiet = quiet, debug = debug,\n                    X.mu1 = X.mu1, X.sigma1 = X.sigma1, X.mu2 = X.mu2, X.sigma2 = X.sigma2,y=y,\n                    fun1 = fun1, fun2 = fun2, fun3=fun3,fun4=fun4,\n                    idx.fixed = idx.fixed, idx.var = idx.var,fixed = fixed,\n                    scale = scale, scaleInit = scaleInit)\n\n   res = fitConvreg(listParam,method)\n\n   opt.fin = res$opt\n\n   profile.lik = res$prof\n\n   Hessian = opt.fin$hessian\n\n   theta.est = matrix(res$theta, ncol=1)\n\n   attr(theta.est, \"names\") <- names(res$theta)\n\n   if(dist1 != \"Multinom\"){\n\n      rownames(theta.est) = attr(theta.est,\"names\")\n\n      idx.mu1 = seq_len(ncol(X.mu1));\n      idx.sigma1 = seq_len(ncol(X.sigma1)) + max(idx.mu1);\n      idx.mu2 = seq_len(ncol(X.mu2)) + max(idx.sigma1);\n      idx.sigma2 = seq_len(ncol(X.sigma2)) + max(idx.mu2);\n\n      # estimation of distution parameter\n\n      mu1 = as.matrix(fun1(X.mu1 %*% theta.est[idx.mu1]))\n\n      sigma1 = as.matrix(fun2(X.sigma1 %*% theta.est[idx.sigma1]))\n\n\n      if(dist1 == \"HP\"){sigma1 = 1-sigma1}\n\n      mu2 = as.matrix(fun3(X.mu2 %*% theta.est[idx.mu2]))\n\n      sigma2 = as.matrix(fun4(X.sigma2 %*% theta.est[idx.sigma2]))\n\n      if(dist1 == \"Nbinom\" | dist1 == \"Pois\"){exp1 = mu1}\n      if(dist1 == \"Binom\"){exp1 = mu1*sigma1}\n      if(dist1 == \"CoMPoisson\"){exp1 = Zcomp.mu(mu1,sigma1)}\n      if(dist1 == \"ZIP\"){exp1 = mu1 * (1 - sigma1)}\n      if(dist1 == \"HP\"){exp1 = mu1 / (1 - exp(-mu1)) * (1-sigma1)}\n\n      if(dist2 == \"Gauss\"){exp2 = mu2}\n      if(dist2 == \"Lnorm\"){exp2 = exp(mu2 + sigma2^2/2)}\n\n      y.fitted = exp1 + exp2\n\n      if(scale){y.fitted = res$scalePar*exp1 + exp2}\n\n      fisher_info <- ginv(-Hessian)\n      s.e = rep(0,length(theta.est))\n      s.e[idx.var]<-sqrt(diag(fisher_info))\n\n      upper<-theta.est+1.96*s.e\n      lower<-theta.est-1.96*s.e\n\n      df.residuals = length(y) - length(idx.var)\n      df.null = length(y) -1\n      niter <- c(f.evals = opt.fin$counts[1L], g.evals = opt.fin$counts[2L])\n\n      par.est = data.frame(Estimate = theta.est, Std.Error = s.e,\n                           Low = lower, Upp = upper,\n                           t.value = theta.est / s.e,\n                           p.value = 2.0 * pt(-abs(theta.est / s.e), df = df.residuals),\n                           row.names = rownames(theta.est))\n\n   }\n\n      xdata <- data.frame(\n         time=1:length(y),\n         y=y,\n         y.fitted,\n         X.mu1,\n         X.sigma1,\n         X.mu2,\n         X.sigma2)\n\n      names(xdata)[2] <- 'y'\n\n      RET<-list(estimation=par.est, fitted = y.fitted, xdata=xdata, data = data, theta.i = c(init.theta$mu1, init.theta$sigma1,init.theta$mu2, init.theta$sigma2),\n                idx = list(init.theta$idx1,init.theta$idx1b,init.theta$idx2,init.theta$idx2b),\n                #residuals = residuals,\n                hessian=Hessian, loglik = opt.fin$value,\n                transforms = list(fun1,fun2,fun3,fun4), df.residuals = df.residuals,\n                niter = niter,distname = paste(dist1, dist2, sep=\"/\"), df.null = df.null,\n                method = method, formulas = list(mu1 = formula.mu1, sigma1 = formula.sigma1,mu2 = formula.mu2,sigma2 = formula.sigma2),\n                aic = 2*length(theta.est) - 2*opt.fin$value,code = opt.fin$convergence, profile.lik = profile.lik,\n                message = opt.fin$message, call = call,scale = scale,\n                scalePar = res$scalePar, model.terms = list(X.mu1.model.terms, X.sigma1.model.terms, X.mu2.model.terms, X.sigma2.model.terms))\n\n\n   class(RET) <- 'convreg'\n   if(!quiet){message (\" ** done\")}\n   return(RET)\n\n}\n",
    "created" : 1484104174846.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "211774728",
    "id" : "D17D86BB",
    "lastKnownWriteTime" : 1484696353,
    "last_content_update" : 1484696353599,
    "path" : "~/Documents/Donnees/Code/Package/convReg/R/convreg.R",
    "project_path" : "R/convreg.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}