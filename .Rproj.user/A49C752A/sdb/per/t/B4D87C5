{
    "collab_server" : "",
    "contents" : "fitConvreg <- function(paramList, method){\n\n   theta.est = rep(0,ncol(paramList$X.mu1)+ncol(paramList$X.sigma1)+ncol(paramList$X.mu2)+ncol(paramList$X.sigma2))\n\n   theta.name = c(paste(\"mu 1: \",colnames(paramList$X.mu1),sep=\"\"),\n                  paste(\"sigma 1: \",colnames(paramList$X.sigma1),sep=\"\"),\n                  paste(\"mu 2: \",colnames(paramList$X.mu2),sep=\"\"),\n                  paste(\"sigma 2: \",colnames(paramList$X.sigma2),sep=\"\"))\n\n   theta.est[paramList$init.theta$idx1] = paramList$init.theta$theta.mu1\n   theta.est[paramList$init.theta$idx1b] = paramList$init.theta$theta.sigma1\n   theta.est[paramList$init.theta$idx2] = paramList$init.theta$theta.mu2\n   theta.est[paramList$init.theta$idx2b] = paramList$init.theta$theta.sigma2\n\n   theta.est[paramList$idx.fixed] = paramList$fixed$value\n\n   names(theta.est) = theta.name\n\n   idx.na = which(is.na(theta.est))\n\n   if(length(idx.na) > 0){\n      if(!paramList$quiet){message(sprintf('NA coefficients estimated, dropping variables: %s', theta.name[idx.na]))}\n\n      paramList$idx.fixed = c(paramList$idx.fixed, idx.na)\n      paramList$idx.var   =  which(!(theta.name %in% c(paramList$fixed$name, theta.name[idx.na])))\n\n      paramList$fixed$name = c(paramList$fixed$name,theta.name[idx.na])\n      paramList$fixed$value = c(paramList$fixed$value, rep(0, length(idx.na)))\n   }\n\n   N.THETA   <- ncol(paramList$X.mu1)\n   N.THETA.2 <- ncol(paramList$X.mu2)\n   N.SIGMA   <- ncol(paramList$X.sigma1)\n\n   if(method == \"mle\"){\n\n      if(paramList$dist1 != \"Multinom\"){\n\n\n         # optimization of parameter\n\n         status = 1\n         num = 0\n\n         while( status != 0  & num < 50){\n            num = num + 1\n            if(!paramList$quiet){message(sprintf(' ** optimization attempt num %s : [please wait]', num ))}\n\n            theta.0 = theta.est[paramList$idx.var]\n\n            #\n            ll.cv = function(theta){ loglikConvreg(theta,paramList$fixed, paramList$idx.var, paramList$idx.fixed,\n                                                      paramList$y,paramList$X.mu1,paramList$X.sigma1, paramList$X.mu2,paramList$X.sigma2,\n                                                      N.THETA, N.SIGMA, N.THETA.2,\n                                                      paramList$fun1, paramList$fun2, paramList$fun3, paramList$fun4,\n                                                      paramList$dist1,paramList$dist2,paramList$weights)}\n\n            dll.cv = function(theta){ dloglikConvreg(theta,paramList$fixed, paramList$idx.var, paramList$idx.fixed,\n                                                        paramList$y,paramList$X.mu1,paramList$X.sigma1, paramList$X.mu2,paramList$X.sigma2,\n                                                        N.THETA, N.SIGMA, N.THETA.2,\n                                                        paramList$fun1, paramList$fun2, paramList$fun3, paramList$fun4,\n                                                        paramList$dist1,paramList$dist2,paramList$weights)}\n\n            if(paramList$dist1 %in% c(\"ZIP\",\"HP\")){\n               opt.reg = optim(theta.0, fn = ll.cv,gr = NULL, method = \"BFGS\", control = list(fnscale = -1), hessian=T)\n            }else{\n               opt.reg = optim(theta.0, fn = ll.cv, gr = dll.cv, method = \"BFGS\", control = list(fnscale = -1), hessian=T)\n            }\n\n            status = opt.reg$convergence\n            theta.est[paramList$idx.var] = opt.reg$par\n         }\n\n      }\n      scaleP = NULL\n   }\n   if(method == \"em\"){\n\n\n      theta0 = list(init = c(paramList$init.theta[[1]],paramList$init.theta[[2]],paramList$init.theta[[3]],paramList$init.theta[[4]]),\n                    indices = list(idx1 = paramList$init.theta$idx1,\n                                   idx1b = paramList$init.theta$idx1b,\n                                   idx2 = paramList$init.theta$idx2,\n                                   idx2b = paramList$init.theta$idx2b))\n\n\n\n      res.em = convRegEM(paramList$formula.resp,paramList$formula.mu1, paramList$formula.sigma1, paramList$formula.mu2, paramList$formula.sigma2,\n                         dist1 = paramList$dist1, dist2 = paramList$dist2,df = paramList$data, theta.0 = theta0,\n                         X.mu1 = paramList$X.mu1,X.sigma1 = paramList$X.sigma1,X.mu2 = paramList$X.mu2,X.sigma2 = paramList$X.sigma2,\n                         fun1 = paramList$fun1,fun2 = paramList$fun2,fun3 = paramList$fun3,fun4 = paramList$fun4,\n                         weights = paramList$weights, quiet = paramList$quiet, debug = paramList$debug,\n                         scale = paramList$scale, scaleInit = paramList$scaleInit)\n\n      scaleP = res.em$scale\n      status = max(1-res.em$opt1$converged,1-res.em$opt2$converged)\n      theta.est[paramList$idx.var] = res.em$par\n\n\n      ll = function(x0){\n         loglikConvreg(x0, paramList$fixed, paramList$idx.var, paramList$idx.fixed,\n                        paramList$y,paramList$X.mu1,paramList$X.sigma1, paramList$X.mu2,paramList$X.sigma2,\n                        N.THETA, N.SIGMA, N.THETA.2,\n                        paramList$fun1, paramList$fun2, paramList$fun3, paramList$fun4,\n                        paramList$dist1,paramList$dist2, paramList$weights)\n      }\n\n      Hessian = numDeriv::hessian(func = ll, x = theta.est[paramList$idx.var])\n\n      opt.reg = list(value = ll(theta.est[paramList$idx.var]), counts = rep(nrow(res.em$par.hist),2),\n                     message = \"\", convergence = status, hessian = Hessian)\n\n   }\n\n   profile.lik = list(\n      param = (theta.est[paramList$idx.var]),\n      other = list(paramList$fixed, paramList$idx.var, paramList$idx.fixed,\n                   paramList$y,paramList$X.mu1,paramList$X.sigma1, paramList$X.mu2,paramList$X.sigma2,\n                   N.THETA, N.SIGMA, N.THETA.2,\n                   paramList$fun1, paramList$fun2, paramList$fun3, paramList$fun4,\n                   paramList$dist1,paramList$dist2, paramList$weights)\n   )\n\n   return(list(opt = opt.reg, prof = profile.lik, theta = theta.est, scalePar = scaleP))\n}\n\n#' @export\nvcov.convreg <- function(object, ...) {\n   vcov <- -solve(object$hessian)\n   return(vcov)\n}\n\n#' @export\ncoef.convreg <- function(object, ...) {\n   return(list(theta_mu1 = object$estimation$Estimate[object$idx[[1]]],\n               theta_sigma1 = object$estimation$Estimate[object$idx[[2]]],\n               theta_mu2 = object$estimation$Estimate[object$idx[[3]]],\n               theta_sigma2 = object$estimation$Estimate[object$idx[[4]]]))\n}\n\n#' @export\npredict.convreg <- function(object, newdata = NULL, ...){\n\n  obj = object\n\n  if(is.null(newdata)){newdata = obj$data}\n\n  idx.p1 = index.convreg(obj)[[1]]\n  idx.p2 = index.convreg(obj)[[2]]\n  idx.p3 = index.convreg(obj)[[3]]\n  idx.p4 = index.convreg(obj)[[4]]\n\n  dist1= unlist(strsplit(obj$distname,\"/\"))[1]\n  dist2= unlist(strsplit(obj$distname,\"/\"))[2]\n\n  formula.mu1 = as.formula(obj$formulas$mu1)\n  formula.sigma1 = as.formula(obj$formulas$sigma1)\n  formula.mu2 = as.formula(obj$formulas$mu2)\n  formula.sigma2 = as.formula(obj$formulas$sigma2)\n\n  X.mu1.model.frame = model.frame(formula.mu1,data = newdata,na.action=NULL, drop.unused.levels = TRUE)\n  X.mu1.model.terms = attr(X.mu1.model.frame,\"terms\")\n  X.mu1 = model.matrix(X.mu1.model.terms, X.mu1.model.frame)\n\n  X.sigma1.model.frame = model.frame(formula.sigma1,data = newdata,na.action=NULL, drop.unused.levels = TRUE)\n  X.sigma1.model.terms = attr(X.sigma1.model.frame,\"terms\")\n  X.sigma1 = model.matrix(X.sigma1.model.terms, X.sigma1.model.frame)\n\n  X.mu2.model.frame = model.frame(formula.mu2,data = newdata,na.action=NULL, drop.unused.levels = TRUE)\n  X.mu2.model.terms = attr(X.mu2.model.frame,\"terms\")\n  X.mu2 = model.matrix(X.mu2.model.terms, X.mu2.model.frame)\n\n  X.sigma2.model.frame = model.frame(formula.sigma2,data = newdata,na.action=NULL, drop.unused.levels = TRUE)\n  X.sigma2.model.terms = attr(X.sigma2.model.frame,\"terms\")\n  X.sigma2 = model.matrix(X.sigma2.model.terms, X.sigma2.model.frame)\n\n\n  if(dist1 != \"Multinom\"){mu1 = obj$transforms[[1]](X.mu1 %*% obj$estimation$Estimate[idx.p1])}\n  if(dist1 == \"Multinom\"){mu1 = exp(X.mu1 %*% cbind(rep(0,ncol(X.mu1)),t(matrix(obj$estimation$Estimate[idx.p1], nrow = obj$estimation$Estimate[idx.p2])))) / rowSums( exp(X.mu1 %*% cbind(rep(0,ncol(X.mu1)),t(matrix(obj$estimation$Estimate[idx.p1], nrow = obj$estimation$Estimate[idx.p2])))))}\n\n  sigma1 = obj$transforms[[2]](X.sigma1 %*% obj$estimation$Estimate[idx.p2])\n  mu2 = obj$transforms[[3]](X.mu2 %*% obj$estimation$Estimate[idx.p3])\n  sigma2 = obj$transforms[[4]](X.sigma2 %*% obj$estimation$Estimate[idx.p4])\n\n  if(dist1 == \"Nbinom\" | dist1 == \"Pois\"){exp1 = mu1}\n  if(dist1 == \"Binom\"){exp1 = mu1*sigma1}\n  if(dist1 == \"CoMPoisson\"){exp1 = Zcomp.mu(mu1,sigma1)}\n  if(dist1 == \"ZIP\"){exp1 = mu1 * (1 - sigma1)}\n  if(dist1 == \"HP\"){exp1 = mu1 / (1 - exp(-mu1)) * (1-sigma1)}\n\n  if(dist2 == \"Gauss\"){exp2 = mu2}\n  if(dist2 == \"Lnorm\"){exp2 = exp(mu2 + sigma2^2/2)}\n\n  y.fitted = exp1 + exp2\n\n  RET = data.frame(y = obj$xdata$y ,pred = y.fitted, k = exp1, mu1 = mu1, s1 = sigma1, e = exp2, mu2 = mu2, s2= sigma2)\n\n  return(RET)\n}\n\n#' @export\nsummary.convreg <- function(object,... ) {\n  if(!inherits(object, \"convreg\"))\n    stop(\"'summary.convreg' called on a non-'convreg' object\")\n  ## Here we should actually coerce the object to a 'convreg' object, dropping all the subclasses...\n  ## Instead, we force the program to use convreg-related methods\n  result <- object$maxim\n  nParam <- length(object$estimation$Estimate)\n  results <- object$estimation\n\n  summary <- list(maximType=object$method,\n                  distr=object$distname,\n                  returnCode=object$code,\n                  returnMessage=object$message,\n                  loglik=object$loglik,\n                  estimate=results,\n                  NActivePar=nParam,\n                  constraints=object$constraints,\n                  indices = object$idx)\n  class(summary) <- \"summary.convreg\"\n  summary\n}\n\n#' @export\nprint.convreg <- function(x, ...) {\n  obj = x\n  cat(\"\\nCall:\\n\")\n  print(obj$call)\n  cat(\"\\nTheta_mu1:\\n\")\n  print(obj$estimation$Estimate[obj$idx[[1]]])\n  cat(\"\\nTheta_mu2:\\n\")\n  print(obj$estimation$Estimate[obj$idx[[3]]])\n  cat(\"\\nDegrees of Freedom:\", obj$df.null,\"Total (i.e. Null);\", obj$df.residual , \"Residual\\n\")\n  cat(\"AIC:\", obj$aic,\"\\n\")\n  cat(\"Log-Likelihood:\", obj$loglik, \"\\n\")\n  invisible(obj)\n}\n\n#' @export\nprint.summary.convreg <- function(x, ... ) {\n  cat(\"--------------------------------------------\\n\")\n  cat(\"Convolution Regression Results\",\"\\n\")\n  cat(toupper(x$maximType), \", \", x$distr,\"\\n\", sep=\"\")\n  cat(\"Return code \", x$returnCode, \": \", x$returnMessage, \"\\n\", sep=\"\")\n  if(!is.null(x$estimate)) {\n    cat(\"Log-Likelihood:\", x$loglik, \"\\n\")\n    cat(x$NActivePar, \" free parameters\\n\")\n    cat(\"\\n\")\n    cat(paste(\"Estimates: \",strsplit(x$distr,\"/\")[[1]][1] ,\"\\n\"))\n    printCoefmat(x$estimate[c(x$indices[[1]],x$indices[[2]]),])\n    cat(\"\\n\")\n    cat(paste(\"Estimates: \",strsplit(x$distr,\"/\")[[1]][2] ,\"\\n\"))\n    printCoefmat(x$estimate[c(x$indices[[3]],x$indices[[4]]),])\n\n  }\n  if(!is.null(x$constraints)) {\n    cat(\"\\nWarning: constrained likelihood estimation.\",\n        \"Inference is probably wrong\\n\")\n    cat(\"Constrained optimization based on\", x$constraints$type,\n        \"\\n\")\n    if(!is.null(x$constraints$code))\n      cat(\"Return code:\", x$constraints$code, \"\\n\")\n    # note: this is missing for 'constrOptim'\n    if(!is.null(x$constraints$message))\n      cat(x$constraints$message, \"\\n\")\n    # note: this is missing for 'constrOptim'\n    cat(x$constraints$outer.iterations,\n        \" outer iterations, barrier value\",\n        x$constraints$barrier.value, \"\\n\")\n  }\n  cat(\"--------------------------------------------\\n\")\n}\n\n\n\n#' Calculate quantile residuals\n#' @param obj convreg object\n#' @param ... additional parameters\n#' @keywords convolution\n#' @export\nquantRes <- function(obj, ...) {\n\n   p = predict(obj)\n\n   dist1= unlist(strsplit(obj$distname,\"/\"))[1]\n   dist2= unlist(strsplit(obj$distname,\"/\"))[2]\n\n   if(dist1 == \"Pois\"){\n     E = eval(parse(text = sprintf(\"apply(cbind(p$y,p$mu1,p$mu2,p$s2),1,function(x) p%s%s(x[1],x[2], x[3],x[4]))\", dist1, dist2)))\n   }else{\n     E = eval(parse(text = sprintf(\"apply(cbind(p$y,p$mu1,p$s1,p$mu2,p$s2),1,function(x) p%s%s(x[1],x[2], x[3],x[4], x[5]))\", dist1, dist2)))\n   }\n\n\n   if(obj$scale){\n      if(dist2 %in% \"Gauss\"){wdist2 = \"norm\"}\n      if(dist2 %in% \"Lnorm\"){wdist2 = \"lnorm\"}\n      if(dist2 %in% \"Gamma\"){wdist2 = \"gamma\"}\n\n      if(dist1 %in% \"Pois\"){wdist1 = \"poisson\"\n      E =  eval(parse(text = sprintf(\"apply(cbind(p$y,p$mu1,p$s1,p$mu2,p$s2),1,function(x){\n               rd.p = 0:200\n               res = sum(p%s(x[1]-obj$scalePar*rd.p,x[4], x[5])*dpois(rd.p,x[2]))}\n            )\", wdist2)))\n            }\n      if(dist1 %in% \"Nbinom\"){wdist1 = \"nbinom\"\n      E = eval(parse(text = sprintf(\"apply(cbind(p$y,p$mu1,p$s1,p$mu2,p$s2),1,function(x){\n               rd.p = 0:200\n               res = sum(p%s(x[1]-obj$scalePar*rd.p,x[4], x[5])*dnbinom(rd.p,mu = x[2], size = x[3]))}\n            )\", wdist2)))\n      }\n      if(dist1 %in% \"ZIP\"){wdist1 = \"ZIP\"\n      E = eval(parse(text = sprintf(\"apply(cbind(p$y,p$mu1,p$s1,p$mu2,p$s2),1,function(x){\n               rd.p = 0:200\n               res = sum(p%s(x[1]-obj$scalePar*rd.p,x[4], x[5])*dZIP(rd.p,x[2], x[3]))}\n            )\", wdist2)))\n      }\n      if(dist1 %in% \"HP\"){wdist1 = \"HP\"\n      E = eval(parse(text = sprintf(\"apply(cbind(p$y,p$mu1,p$s1,p$mu2,p$s2),1,function(x){\n               rd.p = 0:200\n               res = sum(p%s(x[1]-obj$scalePar*rd.p,x[4], x[5])*dHP(rd.p,x[2], x[3]))}\n            )\", wdist2)))\n      }\n      if(dist1 %in% \"CoMPoisson\"){wdist1 = \"comp\"\n      E = eval(parse(text = sprintf(\"apply(cbind(p$y,p$mu1,p$s1,p$mu2,p$s2),1,function(x){\n               rd.p = 0:200\n                                res = sum(p%s(x[1]-obj$scalePar*rd.p,x[4], x[5])*dcomp(rd.p,x[2], x[3]))}\n      )\", wdist2)))\n            }\n      if(dist1 %in% \"Binom\"){wdist1 = \"binom\"\n      E = eval(parse(text = sprintf(\"apply(cbind(p$y,p$mu1,p$s1,p$mu2,p$s2),1,function(x){\n               rd.p = 0:200\n               res = sum(p%s(x[1]-obj$scalePar*rd.p,x[4], x[5])*dbinom(rd.p,prob=x[2], size = x[3]))}\n            )\", wdist2)))\n      }\n\n\n   }\n\n   qres = qnorm(E)\n\n   return(qres)\n}\n\n#' @export\nmeanVarianceConvreg <- function(mu1, sigma1,mu2, sigma2,dist1, dist2) {\n\n   if(dist2 %in% \"Gauss\"){variance2 = sigma2^2}\n   if(dist2 %in% \"Lnorm\"){variance2 = exp(2*mu2+sigma2)*(exp(sigma2)-1)}\n   if(dist2 %in% c(\"Gamma\")){variance2 = mu2 * sigma2^2}\n\n   if(dist2 %in% \"Gauss\"){exp2 = mu2}\n   if(dist2 %in% \"Lnorm\"){exp2 = exp(mu2 + sigma2^2/2)}\n   if(dist2 %in% c(\"Gamma\")){exp2 = mu2*sigma2}\n\n   if(dist1 == \"Nbinom\"){exp1 = mu1}\n   if(dist1 == \"Pois\"){exp1 = mu1}\n   if(dist1 == \"ZIP\"){exp1 = mu1*(1-sigma1)}\n   if(dist1 == \"HP\"){exp1 = mu1/(1-exp(-mu1)) * (1-sigma1)}\n   if(dist1 == \"CoMPoisson\"){exp1 = Zcomp.mu(mu1,sigma1)}\n   if(dist1 == \"Binom\"){exp1 = mu1*sigma1}\n   if(dist1 == \"Multinom\"){exp1 = mu1*sigma1}\n\n   if(dist1 == \"Nbinom\"){variance1 = mu1^2/sigma1 + mu1}\n   if(dist1 == \"Pois\"){variance1 = mu1}\n   if(dist1 == \"ZIP\"){variance1 = mu1*(1-sigma1)*(1 + sigma1 * mu1)}\n   if(dist1 == \"HP\"){variance1 = 2*exp(2) / (exp(2)-1) * (1 - (2 / (exp(2)-1))) * (sigma1 * (1 - sigma1))}\n   if(dist1 == \"CoMPoisson\"){variance1 = YY(mu1, sigma1,100) / Z(mu1, sigma1,100) - exp1^2}\n   if(dist1 == \"Binom\"){variance1 = mu1*(1-(mu1/sigma1))}\n   if(dist1 == \"Multinom\"){variance1 = mu1*(1-(mu1/sigma1))}\n\n\n   mean = exp1 + exp2\n   variance = variance1 + variance2\n\n\n   return(list(mean = mean, variance = variance, e1 = exp1, e2=exp2, s1=variance1, s2=variance2))\n}\n\nindex.convreg <- function(obj) {\n   idx.mu1 = obj$idx[[1]]\n   idx.sigma1 = obj$idx[[2]]\n   idx.mu2 = obj$idx[[3]]\n   idx.sigma2 = obj$idx[[4]]\n   return(list(idx.mu1, idx.sigma1, idx.mu2, idx.sigma2))\n}\n\n#' Calculate marginal regression\n#' @param obj convreg object\n#' @param name.reg variable on which calculate the regression\n#' @param bp boolean. If factor.\n#' @param ... additional parameters\n#' @keywords convolution\n#' @export\nmarginalReg <- function(obj, name.reg,bp, ...) {\n\n   idx.var = grep(name.reg ,rownames(obj$estimation))\n\n   idx.data = grep(name.reg ,colnames(obj$data))\n\n   idx.bs = grep(\"bs\", rownames(obj$estimation))\n\n   idx.mu1 = obj$idx[[1]]\n   idx.sigma1 =obj$idx[[2]]\n   idx.mu2 = obj$idx[[3]]\n   idx.sigma2 = obj$idx[[4]]\n\n   theta.mod = matrix(obj$estimation$Estimate, ncol=1)\n   theta.mod[idx.var] = 0\n\n   mu1.fixed = colMeans(obj$profile.lik$other[[5]] %*% theta.mod[idx.mu1])\n   sigma1.fixed = colMeans(obj$profile.lik$other[[6]] %*% theta.mod[idx.sigma1])\n   mu2.fixed = colMeans(obj$profile.lik$other[[7]] %*% theta.mod[idx.mu2])\n   sigma2.fixed = colMeans(obj$profile.lik$other[[8]] %*% theta.mod[idx.sigma2])\n\n\n   theta.var = matrix(0,nrow = length(obj$estimation$Estimate), ncol=1)\n   theta.var[idx.var] = obj$estimation$Estimate[idx.var]\n\n   full.X = cbind(obj$profile.lik$other[[5]],obj$profile.lik$other[[6]],obj$profile.lik$other[[7]],obj$profile.lik$other[[8]])\n\n   if(!bp){range.var = matrix(seq(min(full.X[,idx.var]),max(full.X[,idx.var]),by=diff(range(full.X[,idx.var]))/100),ncol=1)}\n   if(bp){range.var = diag(length(idx.var))}\n\n   #var.X = matrix(full.X[1,], nrow = nrow(range.var), ncol = ncol(full.X), byrow=T)\n\n   if(!is.null(idx.bs)){\n     var.X = matrix(0, nrow = nrow(range.var), ncol = ncol(full.X), byrow=T)\n     var.X[,idx.var] = range.var\n   }else{\n   if(min(idx.var == idx.bs)==1){\n      newX = seq(min(obj$data[,idx.data]),max(obj$data[,idx.data]),by=diff(range(obj$data[,idx.data]))/100)\n      range.var = matrix(newX, ncol=1)\n      bbs = splines::bs(obj$data[,idx.data], degree = length(idx.bs))\n      rrange.var = predict(bbs, newX)\n      var.X = matrix(0, nrow = length(newX), ncol = ncol(full.X), byrow=T)\n      var.X[,idx.var] = rrange.var\n   }else{\n     var.X = matrix(0, nrow = nrow(range.var), ncol = ncol(full.X), byrow=T)\n     var.X[,idx.var] = range.var\n   }\n}\n   X.mu1 = matrix(var.X[,idx.mu1], nrow = nrow(range.var))\n   X.sigma1 = matrix(var.X[,idx.sigma1], nrow = nrow(range.var))\n   X.mu2 = matrix(var.X[,idx.mu2], nrow = nrow(range.var))\n   X.sigma2 = matrix(var.X[,idx.sigma2], nrow = nrow(range.var))\n\n   mu1.var = X.mu1 %*% theta.var[idx.mu1]\n   sigma1.var = X.sigma1 %*% theta.var[idx.sigma1]\n   mu2.var = X.mu2 %*% theta.var[idx.mu2]\n   sigma2.var = X.sigma2 %*% theta.var[idx.sigma2]\n\n   if(bp){mu1.var = c(0, mu1.var)\n   sigma1.var = c(0, sigma1.var)\n   mu2.var = c(0, mu2.var)\n   sigma2.var = c(0, sigma2.var)\n   range.var = rbind(0, range.var)}\n\n   mu.1 = obj$transforms[[1]](mu1.fixed+mu1.var)\n   sigma.1 = obj$transforms[[2]](sigma1.fixed+sigma1.var)\n\n   mu.2 =  obj$transforms[[3]](mu2.fixed+mu2.var)\n   sigma.2 = obj$transforms[[4]](sigma2.fixed+sigma2.var)\n\n\n\n   return(list(values = data.frame(x = range.var,mu1= mu.1, s1=sigma.1, mu2=mu.2, s2=sigma.2), names = rownames(obj$estimation)[idx.var]))\n}\n\n#' @export\nprint.testdist <- function(x, ...) {\n   cat(\"--------------------------------------------\\n\")\n   cat(\"Convolution Regression Distribution Tests\",\"\\n\")\n   cat(\"Assumed distribution: \", x$dist1,\" and \",x$dist2,\"\\n\", sep=\"\")\n   cat(\"Tests results \\n\")\n   cat(\"\\n\")\n   printCoefmat(x$df, digits = 4, P.values = TRUE, has.Pvalue = TRUE)\n   cat(\"\\n\")\n}\n\n\n",
    "created" : 1484706578035.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "0|42|124|0|\n127|39|130|0|\n133|39|138|0|\n201|42|221|0|\n224|35|236|0|\n239|44|271|0|\n280|32|342|0|\n379|32|385|0|\n",
    "hash" : "3979224152",
    "id" : "B4D87C5",
    "lastKnownWriteTime" : 1484709003,
    "last_content_update" : 1484709003728,
    "path" : "~/Documents/Donnees/Code/Package/convReg/R/methods.R",
    "project_path" : "R/methods.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}